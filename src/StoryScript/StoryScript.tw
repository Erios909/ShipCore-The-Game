:: StoryScript [script] {"position":"1925,100"}


/*
Debug Settings.
*/
(function () {
Setting.addHeader("Debug Settings");

function initSettingDebug() {
Config.debug = settings.debug;
}
Setting.addToggle("debug", {
label    : "Enable test/debug mode?",
default  : false,
onInit   : initSettingDebug,
onChange : function () {
initSettingDebug();
window.location.reload();
}
});
})();

if (document.location.href.toLowerCase().includes("/temp/") || document.location.href.toLowerCase().includes("/private/") || hasOwnProperty.call(window, "storyFormat")) {
// Change this to the path where the HTML file is
// located if you want to run this from inside Twine.
setup.Path = "C:\Users\Documents\Twine\Scratch";  // Running inside Twine application
} else { 
setup.Path = "";  // Running in a browser
}
setup.ImagePath = setup.Path + "images/";
setup.SoundPath = setup.Path + "sounds/music/";

$(document).on(':passagestart', function (ev) {
if (!ev.passage.tags.includes('noreturn')) {
State.variables.return = ev.passage.title;
}
});

window.setup = window.setup || {};

window.currentTrackTimeout = null;
window.currentTrack = null;

setup.advanceTrack = function() {
    var track = setup.songList[setup.currentSongIndex];
    var nextTrackIndex = (setup.currentSongIndex + 1) % setup.songList.length;
    var nextTrack = setup.songList[nextTrackIndex];

    // Stop the current track if it's playing
    if (SimpleAudio.tracks.get(track).isPlaying()) {
        SimpleAudio.tracks.get(track).stop();
        window.currentTrack = null;
        clearTimeout(window.currentTrackTimeout);
        window.currentTrackTimeout = null;
    }

    window.setupTrackEndCallback(nextTrack);

    // Update the current track index
    setup.currentSongIndex = nextTrackIndex;
};

// Check to see if trackID is currently loaded
window.TrackExists = function (trackID) {
	return SimpleAudio.tracks.has(trackID);
};

// Check to see if trackID is the currently playing track
window.isPlaying = function (trackID) {
	var track = SimpleAudio.tracks.get(trackID);
	return track !== null && track.isPlaying();
};



$(document).on(':passageend', function () {
    // Accordion toggle for sub-menus
    $(".sub-menu > a").click(function(e) {
        var $this = $(this);
        var $content = $this.next('.content');
        var $icon = $this.find('.sc-icon');

        // Slide up all other sub-menu contents and remove active class
        $(".sub-menu").not($this.parent()).removeClass('active');
        $(".sub-menu .content").not($content).slideUp();

        // Toggle the clicked sub-menu content
        $content.slideToggle();
        $this.parent().toggleClass('active');

        // Rotate the icon
        if ($this.parent().hasClass('active')) {
            $icon.css('transform', 'rotate(-90deg)');
        } else {
            $icon.css('transform', 'rotate(0deg)');
        }

        e.preventDefault();
    });
});


// SAVING AND BACK BUTTON
Config.history.maxStates = 1;

config.saves.isAllowed = function () {
    // Check if the current passage has the 'safe' tag
    if (tags().includes("safe")) {
        return true; // Allow saving in passages with the 'safe' tag
    }
    return false; // Disallow saving in all other passages
};

Config.saves.autosave = function () {
    // Check if the current passage has the "POI" tag
    if (tags().includes("safe")) {
        return true; // Autosave for passages with the "POI" tag
    }
    return false; // Do not autosave for other passages
};



if (document.location.href.toLowerCase().includes("/temp/") || document.location.href.toLowerCase().includes("/private/") || hasOwnProperty.call(window, "storyFormat")) {
	// Change this to the path where this HTML file is
	// located if you want to run this from inside Twine.
	setup.Path = "C:\Users\Documents\Twine\Scratch";  // Running inside Twine application
} else {
	setup.Path = "";  // Running in a browser
}
setup.ImagePath = setup.Path + "images/";
setup.SoundPath = setup.Path + "sounds/";






/* Create the Right UI Bar. */
var $rightUiBar = $('<div id="right-ui-bar"></div>').insertAfter("#ui-bar");

var rightTray = $rightUiBar.append('<div id="right-ui-bar-tray"><button id="right-ui-bar-toggle" tabindex="0" title="Toggle the Right UI bar" aria-label="Toggle the Right UI bar" type="button"></button></div>');

var rightBody = $rightUiBar.append('<div id="right-ui-bar-body"></div>');

/* Attach the toggle button click. */
$rightUiBar.find('#right-ui-bar-toggle').ariaClick({label : "Toggle the Right UI bar"}, () => $rightUiBar.toggleClass('stowed'));

/* Automatically show the contents of the StoryRightSidebar passage in the right-ui-bar-body element. */
postrender["Display Right Sidebar Contents"] = function (content, taskName) {
	setPageElement('right-ui-bar-body', 'StoryRightSidebar');
};




(function () {
    // v1.1.1
    'use strict';

    var characters = new Map();

    function addCharacter (name, displayname, icon) {
		if(icon === undefined && displayname){
			icon = displayname;
			displayname = null;
		}
        if (State.length) {
            throw new Error('addCharacter() -> must be called before story starts');
        }
        if (!name || !icon) {
            console.error('addCharacter() -> invalid arguments');
            return;
        }
        if (characters.has(name)) {
            console.error('addCharacter() -> overwriting character "' + name + '"');
        }
        characters.set(name, {displayName: displayname, image: icon});
    }

    function say ($output, character, text, imgSrc) {
        // 
        var $box = $(document.createElement('div'))
            .addClass(Util.slugify(character) + ' say');

			
        // portrait
        var _img = characters.has(character) ? characters.get(character).image : null;        
        var $img = $(document.createElement('img'))
            .attr('src', imgSrc || _img || '');

        if ($img.attr('src') && $img.attr('src').trim()) {
            $box.append($img);
        }

        // name and content boxes
		var _name =  character.toUpperFirst();
		if (characters.has(character) && characters.get(character).displayName) {
            _name = characters.get(character).displayName;
        }

        $box.append($(document.createElement('p'))
            .wiki(_name))
            .append($(document.createElement('p'))
                .wiki(text));

        if ($output) {
            if (!($output instanceof $)) {
                $output = $($output);
            }
            $box.appendTo($output);
        }

        return $box;
    }

    setup.say = say;
    setup.addCharacter = addCharacter;

    Macro.add('character', {
        // character macro
        handler : function () {
            addCharacter(this.args[0], this.args[1], this.args[2]);
        }
    });

    $(document).one(':passagestart', function () {
        // construct array of character names
        var names = Array.from(characters.keys());
        names.push('say');
        // generate macros
        Macro.add(names, {
            tags : null,
            handler : function () {
                if (this.name !== 'say') {
                    say(this.output, this.name, this.payload[0].contents);
                } else {
                    say(this.output, this.args[0], this.payload[0].contents, this.args[1]);
                }
            }
        });
    });
}());


if (document.location.href.toLowerCase().includes("/temp/") || document.location.href.toLowerCase().includes("/private/") || hasOwnProperty.call(window, "storyFormat")) {
	setup.Path = "C:\Users\Documents\Twine\Scratch";  // Running inside Twine application
} else { 
	setup.Path = "";  // Running in a browser
}
setup.ImagePath = setup.Path + "images/";

// fontSize: Increase or decrease passage font size by "value" pixels.
window.fontSize = function(value) {
	$("#story").css("font-size", (parseInt($("#story").css("font-size")) + value) + "px");
};

// Make it so that paths can work properly when launched from Twine.
if (document.location.href.toLowerCase().includes("/temp/") || document.location.href.toLowerCase().includes("/private/") || hasOwnProperty.call(window, "storyFormat")) {
	// Change this to the path where the HTML file is
	// located if you want to run this from inside Twine.
	setup.Path = "C:\Users\Documents\Twine\Scratch";  // Running inside Twine application
} else {
	setup.Path = "";  // Running in a browser
}
setup.ImagePath = setup.Path + "images/";

// Game icon in tab.  Generated at: https://realfavicongenerator.net
var favIco = setup.ImagePath + "favicon/";
$(document.head).append('<link rel="apple-touch-icon" sizes="180x180" href="' + favIco + 'apple-touch-icon.png">');
$(document.head).append('<link rel="icon" type="image/png" sizes="32x32" href="' + favIco + 'favicon-32x32.png">');
$(document.head).append('<link rel="icon" type="image/png" sizes="16x16" href="' + favIco + 'favicon-16x16.png">');
$(document.head).append('<link rel="manifest" href="' + favIco + 'site.webmanifest">');
$(document.head).append('<link rel="shortcut icon" href="' + favIco + 'favicon.ico">');
$(document.head).append('<meta name="msapplication-TileColor" content="#da532c">');
$(document.head).append('<meta name="msapplication-config" content="' + favIco + 'browserconfig.xml">');
$(document.head).append('<meta name="theme-color" content="#ffffff">');


// This funcitons fires every passage move and decides to hijack or let them continue.

Config.navigation.override = function (dest) {
    console.log("Original Destination:", dest);
    console.log("Current passage tags:", tags());
    console.log("Destination passage tags:", tags(dest));

        // Store the current and destination passage tags in state variables
    State.variables.currentPassageTags = tags();
    State.variables.destinationPassageTags = tags(dest);

  // Inside Config.navigation.override
if (tags().includes("DebtEvent")) {
    console.log("In DebtEvent, waiting for player action.");
    return dest; // Return the current destination without changing it.
}

  
// Check if the destination passage is not an event and if a new day has started.
if (!tags(dest).includes("event") && State.variables.newDay) {
    console.log("New day detected. Triggering day change.");
    State.variables.continue = dest;  // Store the original destination
    State.variables.newDay = false;  // Reset the newDay flag to false to prevent re-triggering the day change.
    console.log("Next Passage:", State.variables.continue);
    return "eventHandler"; // Redirect to the "eventHandler" passage after handling new day logic.
}

// Check for breakdown condition.
if (State.variables.breakdown && !tags().includes("safe") && !tags().includes("conversation") && !tags(dest).includes("safe") && !tags(dest).includes("conversation")) {
    console.log("Breakdown detected. Redirecting to breakdown passage.");
    State.variables.continue = dest;  // Store the original destination

    var currentArea = State.variables.currentArea || 'default'; // Get the current area or default if not set
    var breakdownEvent = setup.breakdownEvents[currentArea] || setup.breakdownEvents.default; // Get breakdown event for the current area or default if none

    dest = breakdownEvent; // Redirect to the selected breakdown event
    console.log("Selected breakdown event:", dest);

    State.variables.breakdown = false; // Reset the breakdown flag
}




// New case: Redirecting from 'poi' to 'travel' tagged passage to an 'event handler' passage.
if (tags().includes("poi") && tags(dest).includes("travel")) {
    console.log("Moving from 'poi' to 'travel'. Redirecting to 'event handler' passage.");
    State.variables.continue = dest;  // Store the original destination
    return "eventHandler"; // Redirect to the "eventHandler" passage after handling travel logic.
}

    // Existing logic for handling random events on travel passages.
    if (tags(dest).includes("travel") && !tags().includes("event")) {
        console.log("Travel passage detected. Checking for event...");

        var currentArea = State.variables.currentArea || 'default';
        console.log("Current Area:", currentArea);

        var events = setup.areaEvents[currentArea] || [];
        console.log("All available events in current area:", events);

        if (random(1, 10) <= 3) {  // 30% chance for an event
            console.log("Event condition met. Attempting to trigger an event...");
            State.variables.continue = dest;  // Store the original destination

            if (events.length > 0) {
                dest = events.random();
                console.log("Selected random event:", dest);
            } else {
                console.log("No events available for this area.");
            }
        } else {
            console.log("Event condition not met. Continuing to the original destination.");
        }
    } else {
        console.log("Not a travel passage or already in an event. Clearing $continue.");
        delete State.variables.continue;
    }

    console.log("Final destination after processing:", dest);
    return dest;
};




// Define a clamp function
Math.clamp = function(value, min, max) {
    return Math.min(Math.max(value, min), max);
};



/* ToggleImages JavaScript - Start */
function allowHide(el) {
	return (!$(el).hasClass("nohide")) && (!$(el).parent().hasClass("nohide"));
}
window.imageRecheck = function () {
	if (settings.images) {
		$("img").each(function () {
			if (allowHide(this)) {
				$(this).addClass("hidden");
			}
		});
	}
};
var toggleImages = function () {
	if (settings.images) {
		// Hide images
		$(".toggle-wrapper").removeClass("pushed");
		window.imageRecheck();
	} else {
		// Show images
		$(".toggle-wrapper").addClass("pushed");
		$("img").removeClass("hidden");
		$("img").each(function () {
			if (allowHide(this)) {
				$(this).attr("src", $(this).data("src"));
			}
		});
	}
};
Setting.addToggle("images", { label: "Hide images?", onChange: toggleImages });
/* You can do <<run toggleImg()>> to toggle the display of images,
		<<run toggleImg(true)>> to hide images,
		and <<run toggleImg(false)>> to show images. */
window.toggleImg = function (val) {
	if (val === undefined) {
		settings.images = !settings.images;
	} else {
		settings.images = !!val;
	}
	Setting.save();
	toggleImages();
	return settings.images;
};
$(document).on("click", ".toggle_handler", function (event) {
	window.toggleImg();
});
$(document).on(":passagerender", function (event) {
	$(event.content).find("img").each(function () {
		if (allowHide(this)) {
			$(this).data("src", $(this).attr("src"));
			if (settings.images) {
				$(this).addClass("hidden").removeAttr("src");
			}
		}
	});
});
$(document).on(":passageend", function (event) {
	window.imageRecheck();
});
/* ToggleImages JavaScript - End */

// Sanitize input to allow only alphanumeric characters. Default to "ErRoR" if input is empty.
window.sanitizeInput = function(input) {
    var sanitized = input.replace(/[^a-zA-Z0-9 ']/g, ''); // Allow alphanumeric characters, spaces, and apostrophes
    return sanitized.length > 0 ? sanitized : 'ErRoR'; // Default to 'ErRoR' if empty
}



window.updateType = function(targetClass) {
    console.log("updateType called for: " + targetClass);

    // Targeting the div with the specified class
    var current = $('div.' + targetClass);
    console.log("Current element:", current);

    // Checking and updating the type attribute
    if (current.attr('type') === 'business-section') {
        current.attr('type', 'business-section.show');
        console.log("Setting type to 'business-section.show'");
    } else {
        current.attr('type', 'business-section');
        console.log("Setting type back to 'business-section'");
    }

    // Hide other sections
    $('div[type="business-section.show"]').not(current).attr('type', 'business-section');
    console.log("Other sections set to 'business-section'");
};





//HEALTH BAR STUFF IS HERE!!!!





window.UpdateStatBar = function (currentValue, maxValue, barId, isInverse) {
    var percentage;
    var minPercentage = 5;
    var barElement = document.getElementById(barId);

    if (currentValue === undefined || currentValue === 0) {
        
        return; // Exit the function early
    }

    percentage = Math.floor((currentValue / maxValue) * 100);

    if (isInverse) {
        percentage = 100 - percentage;
    }

    percentage = Math.max(percentage, minPercentage);

    if (barElement) {
        barElement.style.width = percentage + '%';

        var color;
        if (isInverse) {
            // For inverted bars: Red when full (high percentage), Green when low (low percentage).
            color = percentage >= 75 ? 'red' :
                    percentage >= 50 ? 'orange' :
                    percentage >= 25 ? 'lightgreen' : 'green';
        } else {
            // For non-inverted bars: Green when full (high percentage), Red when low (low percentage).
            color = percentage >= 75 ? 'green' :
                    percentage >= 50 ? 'lightgreen' :
                    percentage >= 25 ? 'orange' : 'red';
        }

        barElement.style.backgroundColor = color;
    }
};






/* SlideWin v1.0 - Start */
// Add the SlideWin window to the page.
var el = document.createElement("div");
el.id = "slideWin";
el.setAttribute("role", "main");
el.setAttribute("aria-labelledby", "slideTitle");
document.body.appendChild(el);
$(el).css({ transform: "translateX(-101vw)", "stroke-width": "101px" });
// Allow the ESC key to hide the SlideWin window.
$(document).on("keyup", function (event) {
	if (($("#slideWin").css("stroke-width") !== "101px") && ((event.key === "Escape") || (event.key === "Esc"))) {
		window.slideWin("hide");
		return false;
	}
});
// The slideWin() function.
setup.slideWinHandler = [];
window.slideWin = function (dir) {
	if ($("#slideWin").css("stroke-width") !== "101px") {  // Hide slide window.
		setup.slideWinPassage = undefined;
		$("#slideWin").attr("tabindex", null);
		$("#slideWin").animate(
			{ "stroke-width": "101px" },  // Hack to get animation to work.
			{	step: function (now, fx) { $(this).css("transform", "translateX(" + (-now) + "vw)"); },
				complete: function () {
					$("#slideWin").empty();
					if (dir !== "hide") {
						window.slideWin(dir);
					}
				},
				duration: 500
			},
			"swing"
		);
		var handler;  // Remove event handlers.
		while (setup.slideWinHandler.length) {
			handler = setup.slideWinHandler.shift();
			$(handler.selector).off(handler.event, "#slideWin", handler.function);
		}
		$("body").removeClass("slideWin");
	} else {  // Show slide window.
		setup.slideWinPassage = dir;
		$("#slideWin").empty().attr("tabindex", 0).wiki('<button class="ur" onclick="slideWin(\'hide\')" tabindex="0" aria-label="Close Save/Load Window">X</button><div id="slideWinContent" tabindex="0"><<include "' + dir + '">></div>');
		$("#slideWin p").each(function () {  // Remove any empty <p> elements.
			if ($(this).text().trim() === "") {
				$(this).remove();
			} else {  // Strip <p> elements from around their contents.
				$(this).children().unwrap();
			}
		});
		$("#slideWin").delay(1).animate(  // Delay prevents animation stutter.
			{ "stroke-width": "0" },  // Hack to get animation to work.
			{	step: function (now, fx) { $(this).css("transform", "translateX(" + (-now) + "vw)"); },
				complete: function () { $("body").addClass("slideWin"); },
				duration: 500
			},
			"swing"
		).focus();
	}
};
/* SlideWin - End */

if (document.location.href.toLowerCase().includes("/temp/") || document.location.href.toLowerCase().includes("/private/") || hasOwnProperty.call(window, "storyFormat")) {
	// Change this to the path where the HTML file is
	// located if you want to run this from inside Twine.
	setup.Path = "C:/Users/Browning/Documents/Twine/Scratch";  // Running inside Twine application
} else { 
	setup.Path = "";  // Running in a browser
}
setup.SoundPath = setup.Path + "sounds/music/";

// Volume Slider, by Chapel; for SugarCube 2
// version 1.2.0 (modified by HiEv)
// For custom CSS for slider use: http://danielstern.ca/range.css/#/

/*
	Changelog:
	v1.2.0:
		- Fixed using/storing the current volume level in the settings.
	v1.1.0:
		- Fixed compatibility issues with SugarCube version 2.28 (still
		  compatible with older versions, too).
		- Added settings API integration for SugarCube 2.26.
		- Internal improvements and greater style consistency with my
		  other work.
		- Added a pre-minified version.
		- By default, the slider is now more granular than before
		  (101 possible positions vs 11). Change the 'current' and
		  'rangeMax' options to 10 to restore the old feel.
*/

(function () {
	// Set initial values.
	var options = {
		current  : 50,  // Default volume level.
		rangeMax : 100,
		step	 : 1,
		setting  : true
	};
	Setting.load();
	if (options.setting && settings.volume) {
		options.current = parseInt(settings.volume);
	}
	var vol = {
		last: options.current,
		start: (options.current / options.rangeMax).toFixed(2)
	};

	// Function to update the volume level.
	function setVolume (val) {
		if (typeof val !== 'number') val = Number(val);
		if (Number.isNaN(val) || val < 0) val = 0;
		if (val > 1) val = 1;
		options.current = Math.round(val * options.rangeMax);
		if (options.setting) {
			settings.volume = options.current;
			Setting.save();
		}
		if ($('input[name=volume]').val() != options.current) {
			$('input[name=volume]').val(options.current);
		}
		try {
			if (SimpleAudio) {
				if (typeof SimpleAudio.volume === 'function') {
					SimpleAudio.volume(val);
				} else {
					SimpleAudio.volume = val;
				}
				return val;
			} else {
				throw new Error('Cannot access audio API.');
			}
		} catch (err) {
			// Fall back to the wikifier if we have to.
			console.error(err.message, err);
			$.wiki('<<masteraudio volume ' + val + '>>');
			return val;
		}
	}

	// Fix the initial volume level display.
	postdisplay['volume-task'] = function (taskName) {
		delete postdisplay[taskName];
		setVolume(vol.start);
	};

	// Grab volume level changes from the volume slider.
	$(document).on('input', 'input[name=volume]', function() {
		var change = parseInt($('input[name=volume]').val());
		setVolume(change / options.rangeMax);
		vol.last = change;
	});

	// Create the <<volume>> macro.
	Macro.add('volume', {
		handler : function () {
			var wrapper = $(document.createElement('span'));
			var slider = $(document.createElement('input'));
			var className = 'macro-' + this.name;
			slider.attr({
				id		: 'volume-control',
				type	: 'range',
				name	: 'volume',
				min		: '0',
				max		: options.rangeMax,
				step	: options.step,
				value	: options.current
			});
			// Class '.macro-volume' and ID '#volume-control' for styling the slider
			wrapper.append(slider).addClass(className).appendTo(this.output);
		}
	});

	// Add Setting API integration for SugarCube 2.26 and higher.
	function updateVolume () {
		setVolume(settings.volume / options.rangeMax);
	}
	if (options.setting) {
		if (Setting && Setting.addRange && typeof Setting.addRange === 'function') {
			Setting.addRange('volume', {
				label : 'Volume: ',
				min : 0,
				max : options.rangeMax,
				step : options.step,
				default : options.current,
				onInit : updateVolume,
				onChange : updateVolume
			});
		} else {
			console.error('This version of SugarCube does not include the `Settings.addRange()` method; please try updating to the latest version of SugarCube.');
		}
	}
}());




/* Keyboard links v1.3 - Start */
var KBIntervalID = 0;
$(document).on(":passagerender", function (ev) {
	clearInterval(KBIntervalID);
	UpdateLinks(ev.content);
	// Search passages for links every 300ms, just in case they get updated, and marks them for key clicks
	KBIntervalID = setInterval(UpdateLinks, 300);
});
// Adds key shortcut indicators to links in passage if there are less than 11 links in the passsage.
function UpdateLinks(Container) {
	// Enables keyboard shortcuts on passages that do not have the "DisableKeyLinks" tag
	if (!tags().includes("DisableKeyLinks")) {
		var Links, i;
		if (typeof Container === "undefined") {
			Container = document;
			Links = $("#passages a").toArray();
		} else {
			Links = $(Container).find("a").toArray();
		}
		if (Links.length > 0) {
			for (i = Links.length - 1; i >= 0; i--) {
				if ($(Links[i]).data("nokeys") || $(Links[i]).parent().data("nokeys")) {
					Links.deleteAt(i);
				}
			}
		}
		if (Links.length === 1) {
			if (!Links[0].id.includes("Link") && !Links[0].id.includes("NextLnk")) {
				Links[0].id = "NextLnk";
			}
		} else if (Links.length >= 1 && Links.length <= 10) {
			if ($("#NextLnk").length > 0) {  // Remove "NextLnk" ID since the passage now has more than one link.
				$("#NextLnk").removeAttr("id");
			}
			var n = 1;
			for (i = 0; i < Links.length; i++) {
				if (!Links[i].id.includes("Link")) {
					while ($(Container).find("#Link" + n).length) {
						++n;
						if (n > 10) {
							break;
						}
					}
					if (n < 10) {
						$("<sup>[" + n + "]</sup>").appendTo(Links[i]);
						Links[i].id = "Link" + n;
					} else if (n === 10) {
						$("<sup>[0]</sup>").appendTo(Links[i]);
						Links[i].id = "Link0";
						break;
					} else {
						break;
					}
				}
			}
		}
	}
}
$(document).on("keyup", function (e) {
	// Enables keyboard shortcuts on passages that do not have the "DisableKeyLinks" tag and when you're not entering text
	if (!tags().includes("DisableKeyLinks") && ($("input:focus").length === 0) && ($("textarea:focus").length === 0) && ($("div[contenteditable='true']:focus").length == 0)) {
		// Trigger next link click on right arrow key or "1" (normal and numpad)
		if (((e.key == "ArrowRight") || (e.key == "1") || (e.keyCode === 97)) && ($("#NextLnk").length > 0)) {
			if (!(tags().includes("IgnoreArrowKeys") && (e.key == "ArrowRight"))) {
				e.preventDefault();
				$("#NextLnk").click();
				return false;
			}
		} else {
			// Trigger link click on keys "0" through "9"
			if ((e.keyCode > 47) && (e.keyCode < 58)) {
				if ($("#Link" + (e.keyCode - 48)).length) {
					e.preventDefault();
					$("#Link" + (e.keyCode - 48)).click();
					return false;
				}
			}
			// Trigger link click on numpad keys "0" through "9"
			if ((e.keyCode > 95) && (e.keyCode < 106)) {
				if ($("#Link" + (e.keyCode - 96)).length) {
					e.preventDefault();
					$("#Link" + (e.keyCode - 96)).click();
					return false;
				}
			}
		}
		// Trigger random click on "." or "r" key
		if ((e.key == ".") || (e.key == "r")) {
			e.preventDefault();
			var Links = $("#passages a"), n, UsableLinks = [];
			if (Links.length > 0) {
				for (n = 0; n < Links.length; n++) {
					if (!$(Links[n]).data("nokey")) {
						UsableLinks.push(n);
					}
				}
				if (UsableLinks.length > 0) {
					n = random(UsableLinks.length - 1);
					Links[UsableLinks[n]].click();
					return false;
				}
			}
		}
		// Trigger back click on left arrow key or backquote
		if ((e.key == "ArrowLeft") || (e.key == "`")) {
			if ((!tags().includes("IgnoreArrowKeys")) || (e.key != "ArrowLeft")) {
				e.preventDefault();
				Engine.backward();
				return false;
			}
		}
	}
});
/* Keyboard links - End */

// Appends a footer div to the UI bar with a horizontal rule, 
// version text, and centered formatting
$("#ui-bar").append('<div id="uifooter"><center><hr id="HuDHr><span class="smallHuDFont">(V0.00263 A Sci-Fi sandbox based on ShipCore)</span></center></div>');


// JavaScript section
setup.MercImages = {
    MidFemaleWhiteA: '/mercenaries/mid/MidFemaleWhiteA.jpg',
    MidFemaleLatinA: '/mercenaries/mid/MidFemaleLatinA.jpg',
    MidFemaleWhiteD: '/mercenaries/mid/MidFemaleWhiteD.jpg',
    MidFemaleLatinB: '/mercenaries/mid/MidFemaleLatinB.jpg',
    MidMaleWhiteB: '/mercenaries/mid/MidMaleWhiteB.jpg',
    MidMaleBlackB: '/mercenaries/mid/MidMaleBlackB.jpg',
    MidMaleAsianB: '/mercenaries/mid/MidMaleAsianB.jpg',
    MidMaleBlackA: '/mercenaries/mid/MidMaleBlackA.jpg',
    MidFemaleBlackA: '/mercenaries/mid/MidFemaleBlackA.jpg',
    MidMaleWhiteA: '/mercenaries/mid/MidMaleWhiteA.jpg',
    MidFemaleAsianB: '/mercenaries/mid/MidFemaleAsianB.jpg',
    MidFemaleBlackB: '/mercenaries/mid/MidFemaleBlackB.jpg',
    MidFemaleWhiteC: '/mercenaries/mid/MidFemaleWhiteC.jpg',
    MidMaleAsianA: '/mercenaries/mid/MidMaleAsianA.jpg',
    MidFemaleAsianA: '/mercenaries/mid/MidFemaleAsianA.jpg',
    MidFemaleWhiteB: '/mercenaries/mid/MidFemaleWhiteB.jpg',
    LowMaleLatinB: '/mercenaries/low/LowMaleLatinB.jpg',
    LowMaleBlackB: '/mercenaries/low/LowMaleBlackB.jpg',
    LowMaleLatinD: '/mercenaries/low/LowMaleLatinD.jpg',
    LowMaleBlackA: '/mercenaries/low/LowMaleBlackA.jpg',
    LowMaleAsianB: '/mercenaries/low/LowMaleAsianB.jpg',
    LowMaleLatinC: '/mercenaries/low/LowMaleLatinC.jpg',
    LowMaleAsianA: '/mercenaries/low/LowMaleAsianA.jpg',
    LowMaleWhiteA: '/mercenaries/low/LowMaleWhiteA.jpg',
    LowFemaleWhiteA: '/mercenaries/low/LowFemaleWhiteA.jpg',
    LowFemaleBlackA: '/mercenaries/low/LowFemaleBlackA.jpg',
    LowMaleWhiteB: '/mercenaries/low/LowMaleWhiteB.jpg',
    LowFemaleAsianA: '/mercenaries/low/LowFemaleAsianA.jpg',
    LowFemaleLatinB: '/mercenaries/low/LowFemaleLatinB.jpg',
    LowFemaleWhiteB: '/mercenaries/low/LowFemaleWhiteB.jpg',
    LowFemaleBlackB: '/mercenaries/low/LowFemaleBlackB.jpg',
    LowMaleLatinA: '/mercenaries/low/LowMaleLatinA.jpg',
    LowFemaleAsianB: '/mercenaries/low/LowFemaleAsianB.jpg',
    LowFemaleLatinA: '/mercenaries/low/LowFemaleLatinA.jpg',
    HighFemaleEasternA: '/mercenaries/high/HighFemaleEasternA.jpg',
    HighMaleEasternB: '/mercenaries/high/HighMaleEasternB.jpg',
    HighMaleWhiteB: '/mercenaries/high/HighMaleWhiteB.jpg',
    HighMaleLatinA: '/mercenaries/high/HighMaleLatinA.jpg',
    HighMaleAsianA: '/mercenaries/high/HighMaleAsianA.jpg',
    HighMaleAsianB: '/mercenaries/high/HighMaleAsianB.jpg',
    HighFemaleEasternB: '/mercenaries/high/HighFemaleEasternB.jpg',
    HighMaleWhiteA: '/mercenaries/high/HighMaleWhiteA.jpg',
    HighFemaleWhiteC: '/mercenaries/high/HighFemaleWhiteC.jpg',
    HighFemaleLatinB: '/mercenaries/high/HighFemaleLatinB.jpg',
    HighFemaleAsianB: '/mercenaries/high/HighFemaleAsianB.jpg',
    HighFemaleLatinA: '/mercenaries/high/HighFemaleLatinA.jpg',
    HighMaleEasternA: '/mercenaries/high/HighMaleEasternA.jpg',
    HighFemaleWhiteD: '/mercenaries/high/HighFemaleWhiteD.jpg',
    HighFemaleAsianC: '/mercenaries/high/HighFemaleAsianC.jpg',
    HighMaleLatinB: '/mercenaries/high/HighMaleLatinB.jpg',
    HighFemaleWhiteA: '/mercenaries/high/HighFemaleWhiteA.jpg',
    HighMaleBlackB: '/mercenaries/high/HighMaleBlackB.jpg',
    HighFemaleBlackA: '/mercenaries/high/HighFemaleBlackA.jpg',
    HighFemaleWhiteB: '/mercenaries/high/HighFemaleWhiteB.jpg',
    HighFemaleAsianD: '/mercenaries/high/HighFemaleAsianD.jpg',
    HighFemaleAsianA: '/mercenaries/high/HighFemaleAsianA.jpg',
    HighFemaleBlackB: '/mercenaries/high/HighFemaleBlackB.jpg',
    HighMaleBlackA: '/mercenaries/high/HighMaleBlackA.jpg'
};

// JavaScript section for Male Mercenaries
setup.MaleMercImages = {
    MidMaleWhiteB: '/mercenaries/mid/MidMaleWhiteB.jpg',
    MidMaleBlackB: '/mercenaries/mid/MidMaleBlackB.jpg',
    MidMaleAsianB: '/mercenaries/mid/MidMaleAsianB.jpg',
    MidMaleBlackA: '/mercenaries/mid/MidMaleBlackA.jpg',
    MidMaleWhiteA: '/mercenaries/mid/MidMaleWhiteA.jpg',
    MidMaleAsianA: '/mercenaries/mid/MidMaleAsianA.jpg',
    LowMaleLatinB: '/mercenaries/low/LowMaleLatinB.jpg',
    LowMaleBlackB: '/mercenaries/low/LowMaleBlackB.jpg',
    LowMaleLatinD: '/mercenaries/low/LowMaleLatinD.jpg',
    LowMaleBlackA: '/mercenaries/low/LowMaleBlackA.jpg',
    LowMaleAsianB: '/mercenaries/low/LowMaleAsianB.jpg',
    LowMaleLatinC: '/mercenaries/low/LowMaleLatinC.jpg',
    LowMaleAsianA: '/mercenaries/low/LowMaleAsianA.jpg',
    LowMaleWhiteA: '/mercenaries/low/LowMaleWhiteA.jpg',
    LowMaleWhiteB: '/mercenaries/low/LowMaleWhiteB.jpg',
    LowMaleLatinA: '/mercenaries/low/LowMaleLatinA.jpg',
    HighMaleEasternB: '/mercenaries/high/HighMaleEasternB.jpg',
    HighMaleWhiteB: '/mercenaries/high/HighMaleWhiteB.jpg',
    HighMaleLatinA: '/mercenaries/high/HighMaleLatinA.jpg',
    HighMaleAsianA: '/mercenaries/high/HighMaleAsianA.jpg',
    HighMaleAsianB: '/mercenaries/high/HighMaleAsianB.jpg',
    HighMaleWhiteA: '/mercenaries/high/HighMaleWhiteA.jpg',
    HighMaleEasternA: '/mercenaries/high/HighMaleEasternA.jpg',
    HighMaleLatinB: '/mercenaries/high/HighMaleLatinB.jpg',
    HighMaleBlackB: '/mercenaries/high/HighMaleBlackB.jpg',
    HighMaleBlackA: '/mercenaries/high/HighMaleBlackA.jpg'
};

// JavaScript section for Female Mercenaries
setup.FemaleMercImages = {
    MidFemaleWhiteA: '/mercenaries/mid/MidFemaleWhiteA.jpg',
    MidFemaleLatinA: '/mercenaries/mid/MidFemaleLatinA.jpg',
    MidFemaleWhiteD: '/mercenaries/mid/MidFemaleWhiteD.jpg',
    MidFemaleLatinB: '/mercenaries/mid/MidFemaleLatinB.jpg',
    MidFemaleBlackA: '/mercenaries/mid/MidFemaleBlackA.jpg',
    MidFemaleAsianB: '/mercenaries/mid/MidFemaleAsianB.jpg',
    MidFemaleBlackB: '/mercenaries/mid/MidFemaleBlackB.jpg',
    MidFemaleWhiteC: '/mercenaries/mid/MidFemaleWhiteC.jpg',
    MidFemaleAsianA: '/mercenaries/mid/MidFemaleAsianA.jpg',
    MidFemaleWhiteB: '/mercenaries/mid/MidFemaleWhiteB.jpg',
    LowFemaleWhiteA: '/mercenaries/low/LowFemaleWhiteA.jpg',
    LowFemaleBlackA: '/mercenaries/low/LowFemaleBlackA.jpg',
    LowFemaleAsianA: '/mercenaries/low/LowFemaleAsianA.jpg',
    LowFemaleLatinB: '/mercenaries/low/LowFemaleLatinB.jpg',
    LowFemaleWhiteB: '/mercenaries/low/LowFemaleWhiteB.jpg',
    LowFemaleBlackB: '/mercenaries/low/LowFemaleBlackB.jpg',
    LowFemaleAsianB: '/mercenaries/low/LowFemaleAsianB.jpg',
    LowFemaleLatinA: '/mercenaries/low/LowFemaleLatinA.jpg',
    HighFemaleEasternA: '/mercenaries/high/HighFemaleEasternA.jpg',
    HighFemaleEasternB: '/mercenaries/high/HighFemaleEasternB.jpg',
    HighFemaleWhiteC: '/mercenaries/high/HighFemaleWhiteC.jpg',
    HighFemaleLatinB: '/mercenaries/high/HighFemaleLatinB.jpg',
    HighFemaleAsianB: '/mercenaries/high/HighFemaleAsianB.jpg',
    HighFemaleLatinA: '/mercenaries/high/HighFemaleLatinA.jpg',
    HighFemaleWhiteD: '/mercenaries/high/HighFemaleWhiteD.jpg',
    HighFemaleAsianC: '/mercenaries/high/HighFemaleAsianC.jpg',
    HighFemaleWhiteA: '/mercenaries/high/HighFemaleWhiteA.jpg',
    HighFemaleBlackA: '/mercenaries/high/HighFemaleBlackA.jpg',
    HighFemaleWhiteB: '/mercenaries/high/HighFemaleWhiteB.jpg',
    HighFemaleAsianD: '/mercenaries/high/HighFemaleAsianD.jpg',
    HighFemaleAsianA: '/mercenaries/high/HighFemaleAsianA.jpg',
    HighFemaleBlackB: '/mercenaries/high/HighFemaleBlackB.jpg'
};


// event macro set, by chapel; for sugarcube 2
// version 2.0.0

(function () {
    setup.eventMacroNamespace = 'macro-event';

    // the <<trigger>> macro
    Macro.add('trigger', {
        handler : function () {
            
            // declare vars
            var evt, $el;
            
            // check for errors
            if (this.args.length > 2 || this.args.length === 0) {
                return this.error('incorrect number of arguments');
            }
            if (typeof this.args[0] != 'string') {
                return this.error('first argument should be a string and a valid event type');
            }
            
            // some setup
            evt = this.args[0];
            $el = (this.args.length === 1 ||
                (this.args[1] && typeof this.args[1] === 'string' &&
                this.args[1].toLowerCase().trim() === 'document')) ?
                $(document) : $(this.args[1]);
            
            // fire the event
            $el.trigger(evt);
            
        }
    });

    // the <<event>> macro: <<event type [selector] [once]>>
    Macro.add(['event', 'on', 'one'], {
           tags : ['which'],
        handler : function () {
            
            var payload = this.payload;
            var method = 'on';
            var evt, sel = '', code = '', i;
            
            if (this.args.length > 3 || this.args.length === 0) {
                return this.error('incorrect number of arguments');
            }
            if (typeof this.args[0] != 'string') {
                return this.error('first argument should be a string and a valid event type');
            }
            if (this.args.length === 2 && typeof this.args[1] == 'string' && this.args[1] !== 'once') {
                sel = this.args[1];
            }
            
            if (this.args.includes('once') || this.name === 'one') {
                method = 'one';
            }

            evt = this.args[0];
            
            $(document)[method](evt + '.' + setup.eventMacroNamespace, sel, this.createShadowWrapper(function (e) {
               if ($("input:focus").length === 0) {
                code = payload[0].contents;
                if (payload.length > 1) {
                    for (i = 1; i < payload.length; i++) {
                        if (payload[i].args.includes(e.which)) {
                            code = code + payload[i].contents;
                        }
                    }
                }
                new Wikifier(null, code);
              }      
            }));
            
        }
    });

    Macro.add('off', {
        handler : function () {
            
            // declare vars
            var evt, $el;
            
            // check for errors
            if (this.args.length > 2 || this.args.length === 0) {
                return this.error('incorrect number of arguments');
            }
            if (typeof this.args[0] != 'string') {
                return this.error('first argument should be a string and a valid event type or namespace');
            }
            
            // some setup
            evt = this.args[0];
            $el = (this.args.length === 1 ||
                (this.args[1] && typeof this.args[1] === 'string' &&
                this.args[1].toLowerCase().trim() === 'document')) ?
                $(document) : $(this.args[1]);
            
            // fire the event
            $el.off(evt);
            
        }
    });

}());

/* <<ScrollTo>> macro: Scrolls the window to the given element ID.
			Waits for element to exist.
			Accepts parameters for scrollIntoView().  See:
https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView

Usage:
	Scroll element into view aligned to the top of the window:
		<<ScrollTo "ElementID">>
	Scroll element into view aligned to the bottom of the window:
		<<ScrollTo "ElementID" false>>
*/
Macro.add('ScrollTo', {
	skipArgs : false,
	handler  : function () {
		if (this.args.length > 0) {
			var Value = this.args[0];
			if (typeof Value === "string" || Value instanceof String) {
				var element = null, params = undefined;
				if (this.args.length > 1) {
					params = this.args[1];
				}
				// wait for element
				var elementWaitID = setInterval(function () {
					element = document.getElementById(Value);
					if (element != null) {
						// stop waiting and set scroll position
						clearInterval(elementWaitID);
						if (params != undefined) {
							element.scrollIntoView(params);
						} else {
							element.scrollIntoView();
						}
					}
				}, 100);
			}
		}
	}
});
/* <<ScrollTo>> macro - End */


/* BUSINESS STUFF HERE! */

// Initialize business type variables for save game compatibility
window.setupBusinessTypeVariables = function() {
    // Check if the variables have already been initialized
    if (typeof State.variables.LowerDeckBusinessTypes === "undefined") {
        State.variables.LowerDeckBusinessTypes = ["Space Bar and Lounge", "Hydroponic Farm", "Scrap Reprocessing"];
    }
    if (typeof State.variables.currentBusinessIndex === "undefined") {
        State.variables.currentBusinessIndex = 0;
    }
};

// Function to show the business type based on the current index
window.showBusinessType = function(direction) {
    // Update the current index based on direction
    State.variables.currentBusinessIndex = (State.variables.currentBusinessIndex + direction + State.variables.LowerDeckBusinessTypes.length) % State.variables.LowerDeckBusinessTypes.length;

    // Get the current business type
    var currentType = State.variables.LowerDeckBusinessTypes[State.variables.currentBusinessIndex];

    // Set the business type variable
    State.variables.LowerDecksBusinessType = currentType;

    // Replace the business type description based on the current selection
    $('#businessTypeDescription').empty();
    switch (currentType) {
        case "Space Bar and Lounge":
            $('#businessTypeDescription').wiki(Story.get("SpaceBarAndLounge").text);
            break;
        case "Hydroponic Farm":
            $('#businessTypeDescription').wiki(Story.get("HydroponicFarm").text);
            break;
        case "Scrap Reprocessing":
            $('#businessTypeDescription').wiki(Story.get("ScrapReprocessing").text);
            break;
    }
};

// Define the LowerDeckBusinessProfitability widget
Macro.add('LowerDeckBusinessProfitability', {
    handler: function () {
        // Check if the required arguments are provided
        if (this.args.length < 1) {
            return this.error('No business type specified for the LowerDeckBusinessProfitability widget.');
        }

        var businessType = this.args[0];

        // Check if the business type is valid
        if (!State.variables.LowerDecksBusinessTypeStats.hasOwnProperty(businessType)) {
            return this.error('Invalid business type specified: ' + businessType);
        }

        var businessStats = State.variables.LowerDecksBusinessTypeStats[businessType];

        // State.variables.LowerDecksBusinessStats is used here because it contains the dynamic location factors
        // for the player's current business location. These factors are set when the player selects a location
        // and are used in the profitability calculations to reflect the current state of the business.
        var locationFactorsArray = State.variables.LowerDecksPlayerBusinessLocationStats;

        // Extract location factors from the array
        var customerAvailability = locationFactorsArray[0];
        var supplyHubAccess = locationFactorsArray[1];
        var dangerLevel = locationFactorsArray[2];
        var taxRate = locationFactorsArray[3];

        // Initialize calculated stats
        var batchSize = businessStats.BatchSize;
        var employeesPerUpgrade = businessStats.EmployeesPerUpgrade;
        var employeeCost = businessStats.EmployeeCost; // Ensure this property is defined in your business stats

        // Initialize total input costs for one batch
        var totalInputCostsForOneBatch = Object.values(businessStats.InputCosts).reduce(function (acc, cost) {
            return acc + cost;
        }, 0) * batchSize;

        // Initialize total employee cost per hour
        var totalEmployeeCostPerHour = employeesPerUpgrade * employeeCost;

        // Define multipliers for each business type
        var businessTypeMultipliers = {
            "Space Bar and Lounge": {
                "CustomerAvailabilityMultiplier": .01,
                "SupplyHubAccessMultiplier": .01,
                "DangerLevelMultiplier": .01,
                "TaxRateMultiplier": .01
            },
            "Hydroponic Farm": {
                "CustomerAvailabilityMultiplier": .02,
                "SupplyHubAccessMultiplier": .02,
                "DangerLevelMultiplier": .02,
                "TaxRateMultiplier": .02
            },
            "Scrap Reprocessing": {
                "CustomerAvailabilityMultiplier": .05,
                "SupplyHubAccessMultiplier": .05,
                "DangerLevelMultiplier": .05,
                "TaxRateMultiplier": .05
            }
            // Add additional business types with their respective multipliers here
        };

        // Get the multipliers for the current business type
        var multipliers = businessTypeMultipliers[businessType];

        // Calculate penalties based on location factors and multipliers
        var customerAvailabilityPenalty = Math.pow(customerAvailability / 100, multipliers.CustomerAvailabilityMultiplier);
        var supplyHubAccessPenalty = Math.pow(supplyHubAccess / 100, multipliers.SupplyHubAccessMultiplier);
        var dangerLevelPenalty = Math.pow((100 - dangerLevel) / 100, multipliers.DangerLevelMultiplier);
        var taxRatePenalty = Math.pow((100 - taxRate) / 100, multipliers.TaxRateMultiplier);

        // Calculate the adjusted sales price per unit using the penalties
        var adjustedSalesPricePerUnit = businessStats.BasePriceOfOutput * customerAvailabilityPenalty * supplyHubAccessPenalty * dangerLevelPenalty * taxRatePenalty;


        // Calculate total sales price for all batches processed in one hour
        var totalSalesPriceForAllBatches = adjustedSalesPricePerUnit * batchSize * businessStats.CyclesPerHour;

        // Calculate profit margin per hour
        var profitMarginPerHour = totalSalesPriceForAllBatches - (totalInputCostsForOneBatch * businessStats.CyclesPerHour) - totalEmployeeCostPerHour;

        // Update state variables with the calculated stats
        State.variables.LowerDecksPlayerBusinessBatchSize = batchSize;
        State.variables.LowerDecksPlayerBusinessEmployeesPerUpgrade = employeesPerUpgrade;
        State.variables.LowerDecksPlayerBusinessCustomerAvailability = customerAvailability;
        State.variables.LowerDecksPlayerBusinessSupplyHubAccess = supplyHubAccess;
        State.variables.LowerDecksPlayerBusinessDangerLevel = dangerLevel;
        State.variables.LowerDecksPlayerBusinessTaxRate = taxRate;
        State.variables.LowerDecksPlayerBusinessAdjustedPricePerUnit = adjustedSalesPricePerUnit;
        State.variables.LowerDecksPlayerBusinessTotalSalesPriceForAllBatches = totalSalesPriceForAllBatches;
        State.variables.LowerDecksPlayerBusinessTotalInputCostsForOneBatch = totalInputCostsForOneBatch;
        State.variables.LowerDecksPlayerBusinessTotalEmployeeCostPerHour = totalEmployeeCostPerHour;
        State.variables.LowerDecksPlayerBusinessProfitMarginPerHour = profitMarginPerHour;
    }
});


/*  Random Event Picker

    Creates a random event picker instance with the specified name.
    
    Every time the picker is evaluated it will pick and fire an event that is has not picked before.
    If all events have been picked before it will fire the default event.

    Arguments: 
        (string) eventName:
            The name of the event picker. 
            All event pickers with the same name share the same state.
        (int) numEvents:
            The number of event indices to generate.
            If there are not enough cases to match all the indices there will be cases where NO event will fire (not even the default).

            NB: This value is required to match between event pickers with the same name. 
            Providing different values can corrupt the shared state.
        (bool, optional) oneIndexed:
            If true the case indices are considered as starting from one (1). [1..10]
            If false the case indices are considered as starting from zero (0). [0..9]

    Container Elements:
        Reset Triggers:
            A selection of tags that are evaluated before an event is picked.
            If a trigger condition succeeds the event pool is reset before a new event is picked. 
            
            <<onChangeResetTrigger Expression>> - Reset trigger
                Evaluates the expression and compares the result to a previous evaluation of the trigger.
                If the result is different the event picker is reset.
                If the result is the same, the trigger is a noop.

        Event Cases - Defines the behaviour of different events that can be picked:
            <<case N... >> - Event tag.
                The contents of this case will be selected whenever the N-th indice is picked.
                Multiple N indices can be defined with a space separator.
            <<default>> - The default event tag. Must be last.
                The contents of this case will be selected whenever all other cases have been previously selected.

    Examples:
    Single Fire Events:
    <<RandomEventPicker "EventName" 2>>
        <<case 0>>
            Event 0 has been fired.
        <<case 1>>
            Event 1 has been fired.
        <<default>>
            The default event has been fired.
    <</RandomEventPicker>>

    Multiple Fire Events:
    <<RandomEventPicker "EventName" 4>>
        <<case 0 2 3>> // This event will fire a total of 3 times before becoming unavailable.
            Event 0 has been fired.
        <<case 1>>
            Event 1 has been fired.
        <<default>>
            The default event has been fired.
    <</RandomEventPicker>>

    Automatic Reset Trigger:
    <<RandomEventPicker "Automatic Reset On New Game Day" 3>>
    <<onChangeResetTrigger $gameDate.getFullYear() + "-" + ($gameDate.getMonth() + 1) + "-" + $gameDate.getDate()>>
    <<case 0>>
        AutoReset Case 0
    <<case 1>>
        AutoReset Case 1
    <<case 2>>
        AutoReset Case 2
    <<default>>
        AutoReset Default
    <</RandomEventPicker>>

 */
Macro.add('RandomEventPicker', {
    tags: ['case', 'default', 'onChangeResetTrigger'],
    
    handler() {
        /* Parameter validation */
        switch (this.args.length) {
            case 0:
                return this.error("No event picker name specified.");
            case 1:
                return this.error("No number of event cases specified.");
        }

        let eventName = this.args[0];
        let numEvents = this.args[1];
        let oneIndexed = this.args.length > 3 ? this.args[2] : false;

        const len = this.payload.length;
        if (len === 1) {
            return this.error("No event cases specified.");
        }

        let i;
        let resetTriggersRegistrationCompleted = false;
        let resetTriggers = [];

        // Sanity checks and loading of reset triggers.
        for(/* Declared previously */ i = 1; i < len; i++) {
            switch (this.payload[i].name) {
                case 'onChangeResetTrigger':
                    if(resetTriggersRegistrationCompleted) {
                        return this.error(`All reset triggers must be registreed before the first <<case>>. Invalid: ${this.payload[i].args.raw}`);
                    }
                    resetTriggers.push(this.payload[i]);
                    break;
                case 'default':
                    if (this.payload[i].args.length > 0) {
						return this.error(`<<default>> does not accept values, invalid: ${this.payload[i].args.raw}`);
					}

					if (i + 1 !== len) {
						return this.error('<<default>> must be the final case');
					}
                    break;
                default:
                    // Marks the reset trigger registration as completed.
                    resetTriggersRegistrationCompleted = true;
                    if (this.payload[i].args.length === 0) {
						return this.error(`no value(s) specified for <<${this.payload[i].name}>> (#${i})`);
					}
                    break;
            }
        }

        // Generate Global Shared State if not generated.
        const internalSharedStateVarName = "$Internals_RandomEventPicker_SharedState";
        let globalSharedState = State.getVar(internalSharedStateVarName);
        if (typeof globalSharedState === "undefined") {
            globalSharedState = new Map();
            if (!State.setVar(internalSharedStateVarName, globalSharedState)) {
                return this.error("Could not generate event picker global shared state.")
            }
        }

        // Generates the shared state for the current event if it does not exist.
        if(!globalSharedState.has(eventName)) {
            globalSharedState.set(eventName, {
                regenerateEventsFlag: true,     // Flag that the events array needs to be seeded again.
                events: [],                     // A collection of randomly generated events that are to be executed in order.
                resetTriggerStates: new Map()  // Map for storing persistent data about automatic reset triggers.
            });
        }

        // Should be pretty straight forward as we set it earlier if one does not exist.
        let eventSharedState = globalSharedState.get(eventName);

        // Evaluate all reset triggers for automatic reset.
        // TODO@Dimi: Possibly use Array.forEach() instead?
        for (/* Declared previously */ i = 0; i < resetTriggers.length; i++) {
            const evaluatedTrigger = resetTriggers[i];
            const resetTriggerStates = eventSharedState.resetTriggerStates;
            // The state key for the currently evaluated reset trigger.
            const resetTriggerSharedStateKey = `${evaluatedTrigger.name}-${i}`;

            let triggerEvalResult;
            switch (evaluatedTrigger.name) {
                // Trigger that flags the event for reset if its expression is changed from the last evaluation.
                case 'onChangeResetTrigger': 
                    // Creates a shared state if it does not exist.
                    if (!resetTriggerStates.has(resetTriggerSharedStateKey)) {
                        resetTriggerStates.set(resetTriggerSharedStateKey, {
                            previousValue: undefined // Stores the value from the previous evaluation.
                        });
                    }

                    const triggerState = resetTriggerStates.get(resetTriggerSharedStateKey);

                    // Evaluates the trigger.
                    try {
                        triggerEvalResult = Scripting.evalJavaScript(evaluatedTrigger.args.full);
                    }
                    catch (ex) {
                        return this.error(`bad evaluation: ${typeof ex === 'object' ? ex.message : ex}`);
                    }

                    // If the trigger event result is different from the previous value,
                    // mark the event for regeneration and save the new result.
                    if(triggerEvalResult !== triggerState.previousValue) {
                        eventSharedState.regenerateEventsFlag = true;
                        triggerState.previousValue = triggerEvalResult;
                    }
                    break;
                default:
                    return this.error(`Unknown trigger: ${triggerName}`);
            }
        }

        // Regenerate the events array if requested.
        if(eventSharedState.regenerateEventsFlag) {
            // Generates an array from 0 to N - 1
            let events = [...Array(numEvents).keys()]
            // TODO@Dimi: Probably move this to a shuffle function.
            // Durstenfeld shuffle - https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm
            for (/* Declared previously */ i = events.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [events[i], events[j]] = [events[j], events[i]];
            }
            // Sets the event queue and resets the regenerate flag.
            eventSharedState.events = events;
            eventSharedState.regenerateEventsFlag = false;
        }


        let success = false;
        
        if(Config.debug) {
            this.debugView.name = eventName;
            this.debugView.title = JSON.stringify(eventSharedState);
        }

        // All events have been fired. Fire the default event.
        if(eventSharedState.events.length === 0) {
            // Finds and executes the default statement.
            for(/* Declared previously */ i = 1; i < len; i++) {
                if(this.payload[i].name === 'default') {
                    success = true;
                    new Wikifier(this.output, this.payload[i].contents);
                    break;
                }
            }
            return;
        }

        // Deque an event from the event queue.
        let selectedEventIndex = eventSharedState.events.shift();
        // Evaluate the clauses
        for (/* Declared previously */ i = 1; i < len; i++) {
            if(this.payload[i].args.some(val => val === selectedEventIndex + (oneIndexed ? 1 : 0))) {
                success = true;
                new Wikifier(this.output, this.payload[i].contents);
                break;
            }
        }
    }
});

/*
    Marks a RandomEventPicker for reset.
    The event picker will regenerate the pool of events from which to pick the next time its invoked.
 */
Macro.add('ResetRandomEvent', {
    handler() {
        switch (this.args.length) {
            case 0:
                return this.error("No event picker name specified.");
        }

        let eventName = this.args[0];

        // Generate Global Shared State if not generated.
        const internalSharedStateVarName = "$Internals_RandomEventPicker_SharedState";
        let globalSharedState = State.getVar(internalSharedStateVarName);
        if (typeof globalSharedState === "undefined") {
            // No need to reset any events if no global state exists.
            return;
        }

        // Sets the regenerate events flag if the event exists.
        if(globalSharedState.has(eventName)) {
            globalSharedState.get(eventName).regenerateEventsFlag = true;
        }
    }
});

Macro.add('WipeRandomEventPickerGlobalState', {
    handler() {
        const internalSharedStateVarName = "$Internals_RandomEventPicker_SharedState";
        State.setVar(internalSharedStateVarName, undefined);
    }
});